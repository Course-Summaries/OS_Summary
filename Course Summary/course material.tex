\documentclass[openany,12pt]{book}
\usepackage[utf8]{inputenc}
\usepackage{etoolbox}
\usepackage{hyperref}
\usepackage{geometry}
\usepackage{titlesec}
\usepackage{fancyhdr}

\usepackage{xr-hyper} % External referencing
% \externaldocument[func:]{../Functions/functions} % Path to functions.aux


\usepackage{array}
\usepackage{booktabs}
\usepackage{xcolor}
\usepackage{listings}

\usepackage{enumitem}
\usepackage{amsthm}
\newtheorem*{definition}{Definition}



% =====================================================
% ============== Listings Formats =====================






\geometry{margin=1in}
\titleformat{\section}{\large\bfseries}{\thesection}{1em}{}
\pagestyle{fancy}
\fancyhead[L]{Course Summary}
\fancyhead[C]{Operating Systems 234123}
\fancyhead[R]{Spring 2025}



% =====================================================
% =====================================================
% =====================================================
% Define new counters
\newcounter{lecture}
\newcounter{tutorial}

% Format titles to look like chapters
\titleformat{\chapter}[display]
  {\normalfont\Huge\bfseries}{\chaptername\ \thechapter}{20pt}{\Huge}

\newcommand{\lecturechaptername}{Lecture}
\newcommand{\tutorialchaptername}{Tutorial}

% Custom "Lecture Chapter"
\newcommand{\lecture}[1]{%
  \clearpage
  \refstepcounter{lecture}
  \renewcommand{\chaptername}{\lecturechaptername}%
  \addcontentsline{toc}{chapter}{Lecture \thelecture: #1}
  \chapter*{Lecture \thelecture: #1}
  \markboth{Lecture \thelecture}{#1}
}

% Custom "Tutorial Chapter"
\newcommand{\tutorial}[1]{%
  \clearpage
  \refstepcounter{tutorial}
  \renewcommand{\chaptername}{\tutorialchaptername}%
  \addcontentsline{toc}{chapter}{Tutorial \thetutorial: #1}
  \chapter*{Tutorial \thetutorial: #1}
  \markboth{Tutorial \thetutorial}{#1}
}
% =====================================================
% =====================================================
% =====================================================

\title{Operating Systems (02340123)\\ Summary - Spring 2025}
\author{Razi \& Yara}
\date{\today}

\begin{document}

\maketitle
\tableofcontents
\newpage



% ====================================================
% ====================================================
% ====================================================
% ------------------- Notes Section ------------------
% ====================================================
% ====================================================
% ====================================================

\part{Lectures \& Tutorials}



% =====================================================
% ================== Lecture 1 ========================
% =====================================================

\lecture{Introduction}

\begin{definition}[Operating System (OS)]
    An Operating System's job is:
    \begin{itemize}
        \item Coordinate the execution of all SW, mainly user apps.
        \item Provide various common services needed by users \& apps.
        \item An OS of a physical server controls its physical devices, e.g. CPU, memory, disks, etc.
        \item An OS of a virtual server only \textit{believes} it does. There's another OS underneath, called \textbf{hypervisor} which fakes it.
    \end{itemize}
\end{definition}

\vspace{1em}
\noindent Using an OS allows us to take advantage of \textbf{\textit{"virtualization"}}:
\begin{itemize}
    \item \textbf{Server Consolidation:} Run multiple servers on one physical server. This is allows for better resource utilization, smaller spaces, and less power consumption.
    \item \textbf{Disentangling SW from HW:} allows for backing up/restoring, live migration, and HW upgrade. This give us the advantage of easier provisioning of new (virtual) servers = "virtual machines", and easier OS-level development and testing.
\end{itemize}

\vspace{1em}
Most importantly, an OS is \textbf{reactive}, "event-driven" system, which means it waits for events to happen and then reacts to them. This is in contrast to typical programs which run from start to end without waiting for external events to occur to invoke them.

\begin{tabular}{|>{\raggedright\arraybackslash}p{3.5cm} | >{\raggedright\arraybackslash}p{6.5cm} | >{\raggedright\arraybackslash}p{5.5cm}|}
    \hline
    \textbf{}                           & \textbf{Typical Programs}                                             & \textbf{OS}                                                                  \\
    \hline
    \textbf{what does it typically do?} & get some input, do some processing, produce output, terminate         & waits \& reacts to ``events''                                                \\
    \hline
    \textbf{structure}                  & has a \texttt{main} function, which is (more or less) the entry point & no \texttt{main}; multiple entry points, one per event                       \\
    \hline
    \textbf{termination}                & end of main                                                           & power shutdown                                                               \\
    \hline
    \textbf{typical goal}               & $\sim$ finish as soon as possible                                     & handle events as quickly as possible $\Rightarrow$ more time for apps to run \\
    \hline
\end{tabular}
\newline
OS events can be classified into two:
\begin{itemize}
    \item \textbf{Asynchronous interrupts:} keyboard, mouse, network, disk, etc. These are events that can happen at any time and the OS must be ready to handle them.
    \item \textbf{Synchronous:} system calls, divide by zero, page faults, etc. These are events that happen as a result of the program's execution and the OS must handle them immediately.
\end{itemize}


\begin{definition}
    [\textbf{Multiplexing}]
    Multiplexing is the ability of an OS to share a single resource (e.g. CPU, memory, disk) among multiple processes or threads. This allows for better utilization of resources and enables multiple applications to run concurrently.
    *Multiprogramming  means multiplexing the CPU recourse.
\end{definition}

Notable services provided by an OS:
\begin{enumerate}
    \item \textbf{Isolation:} Allow multiple processes to coexist using the same resources without stepping on each other's toes.
          Usually achieved by multiplexing the CPU, memory, and other resource done by the OS. However, some physical resources know how to multiplex themselves, e.g. network cards, sometimes called \textit{"self-virtualizing devices"}.
    \item \textbf{Abstraction:} Provides convenience \& portability by:
          \begin{itemize}
              \item offering more meaningful, higher-level interfaces
              \item hiding HW details, making interaction wiht HW easier.
          \end{itemize}
\end{enumerate}



% =====================================================
% ================== Lecture 2 ========================
% =====================================================

\lecture{Processes \& Signals}
\section*{Processes}
Each process is an instance of a program in execution, which includes:
\begin{itemize}
    \item \textbf{Program code:} The actual code of the program.
    \item \textbf{Process state:} The current state of the process, including the program counter, registers, and memory management information.
    \item \textbf{Process control block (PCB):} A data structure used by the OS to manage the process, containing information such as process ID, process state, CPU registers, memory management information, and I/O status information.\\
          A process \underline{doesn't have direct access to its PCB}, it is managed by the OS, i.e. needs privilege level 0 (kernel mode) to access it.
    \item \textbf{Process resources:} The resources allocated to the process, such as memory, file descriptors, and network sockets.
\end{itemize}

\begin{definition}
    [\textbf{Process State}]
    A process can be in one of the following states:
    \begin{itemize}
        \item \textbf{Running:} The process is currently being executed by the CPU.
        \item \textbf{Ready:} The process is ready to be executed but is waiting for the CPU to become available.
        \item \textbf{Waiting:} The process is waiting for an event to occur, such as I/O completion or a signal.
        \item \textbf{Zombie:} The process has terminated but its PCB is still in the system, waiting for the parent process to read its exit status. In this state, the process has released almost all of its resources, but \textcolor{blue}{the PCB is still in the system}.
    \end{itemize}
\end{definition}


As we saw in "ATAM", each process can only access a certain set of utilites and functions, those who require privilege level 3 (user mode). So to access the OS services, a process must use \textbf{system calls} which are functions provided by the OS that allow processes to request services from the OS. System calls are typically implemented in the OS kernel and provide a controlled interface for processes to interact with the OS.

\vspace{1em}

Each \textit{syscall}, in case of an error, will change the \texttt{errno} variable to indicate the error type. The \texttt{errno} variable is a global variable that is set by system calls and some library functions in the event of an error to indicate what went wrong. It is defined in the header file \texttt{errno.h}. {\color{blue}\textbf{Note:} \texttt{errno} is not reset to 0 after a successful syscall, so it must be checked immediately after the syscall, and be reset before usage if need be} (if there is not any other way to make sure there is an error indeed).\\
i.e. \texttt{errno=}


\begin{lstlisting}[language=C++, caption={Example of using \texttt{errno} in C}, label={lst:errno_example}]
#include <stdio.h>
#include <errno.h>
#include <string.h>
#include <unistd.h>
int main() {
    FILE *file = fopen("non_existent_file.txt", "r");
    if (file == NULL) {
        // An error occurred, print the error message
        printf("Error opening file: %s\n", strerror(errno));
        return 1;
    }
    fclose(file);
    return 0;
}
\end{lstlisting}






















% ==================================================== 
% ==================================================== 
% ==================================================== 
% ----------------- Summary Section ------------------
% ==================================================== 
% ==================================================== 
% ==================================================== 
\newpage
\part{Overall Summary}
















% ==================================================== 
% ==================================================== 
% ==================================================== 
% --------------- Highlights Section ----------------=
% ==================================================== 
% ==================================================== 
% ==================================================== 
\newpage
\part{Highlights and Notes}



\end{document}